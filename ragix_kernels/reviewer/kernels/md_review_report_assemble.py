"""
Kernel: md_review_report_assemble
Stage: 3 (Reporting)

Generate REVIEW_doc.md from the ledger: run metadata, summary counts,
per-section change table, full chronological ledger.

Author: Olivier Vitrac, PhD, HDR | olivier.vitrac@adservio.fr | Adservio | 2026-02-06
"""

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List

from ragix_kernels.base import Kernel, KernelInput
from ragix_kernels.reviewer.ledger import Ledger

import logging

logger = logging.getLogger(__name__)


def _build_report(
    doc_name: str,
    ledger: Ledger,
    doc_hash: str,
    run_id: str = "",
) -> str:
    """Build the REVIEW_doc.md content from ledger entries."""
    entries = ledger.filter(is_revert=False)
    counts = ledger.summary_counts()

    lines: List[str] = []
    lines.append(f"# Review Report â€” {doc_name}")
    lines.append("")
    lines.append(f"**Run ID:** {run_id or 'N/A'}")
    lines.append(f"**Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}")
    lines.append(f"**Tool:** reviewctl (KOAS Reviewer v1.0.0)")
    lines.append(f"**Doc hash (before):** `{doc_hash}`")
    lines.append("")

    # Overview
    lines.append("## Overview")
    lines.append("")
    lines.append(f"- **Attention changes:** {counts['attention_changes']}")
    lines.append(f"- **Deletions (commented):** {counts['deletions']}")
    lines.append(f"- **Silent minor edits (logged):** {counts['silent_minor']}")
    lines.append(f"- **Total changes:** {counts['total_changes']}")
    if counts['reverts'] > 0:
        lines.append(f"- **Reverts:** {counts['reverts']}")
    lines.append("")

    # Per-section table
    lines.append("## By Section")
    lines.append("")

    # Group entries by scope
    by_section: Dict[str, List] = {}
    for entry in entries:
        section = entry.scope.get("anchor", "unscoped") if entry.scope else "unscoped"
        by_section.setdefault(section, []).append(entry)

    if by_section:
        for section, section_entries in sorted(by_section.items()):
            lines.append(f"### {section}")
            lines.append("")
            for entry in section_entries:
                severity_tag = entry.severity.upper() if entry.severity else "MINOR"
                silent_tag = " (silent)" if entry.silent else ""
                summary = entry.summary[:100] if entry.summary else entry.rationale[:100]
                lines.append(
                    f"- **{entry.id}** ({severity_tag}{silent_tag}): {summary}"
                )
            lines.append("")
    else:
        lines.append("*No changes recorded.*")
        lines.append("")

    # Full ledger (chronological)
    lines.append("## Full Ledger (Chronological)")
    lines.append("")

    all_entries = ledger.get_all()
    if all_entries:
        lines.append("| ID | Kind | Severity | Silent | Summary |")
        lines.append("|---|---|---|---|---|")
        for entry in all_entries:
            revert_tag = " (REVERT)" if entry.is_revert else ""
            summary = (entry.summary or entry.rationale or "")[:80]
            lines.append(
                f"| {entry.id}{revert_tag} | {entry.kind} | "
                f"{entry.severity} | {'yes' if entry.silent else 'no'} | {summary} |"
            )
        lines.append("")
    else:
        lines.append("*No entries.*")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Generated by KOAS Reviewer â€” kernel-enforced, fully traceable.*")

    return "\n".join(lines)


class MdReviewReportAssembleKernel(Kernel):
    """Generate REVIEW_doc.md from ledger."""

    name = "md_review_report_assemble"
    version = "1.0.0"
    category = "reviewer"
    stage = 3
    description = "Generate REVIEW_doc.md from ledger"

    requires: List[str] = ["md_apply_ops"]
    provides: List[str] = ["review_report"]

    def compute(self, input: KernelInput) -> Dict[str, Any]:
        doc_name = Path(input.config.get("doc_path", "doc.md")).name

        # Load ledger
        ledger_path = input.workspace / "review" / "ledger.jsonl"
        ledger = Ledger(ledger_path)

        # Get doc hash
        inv_path = input.workspace / "stage1" / "md_inventory.json"
        doc_hash = ""
        if inv_path.exists():
            inv_data = json.loads(inv_path.read_text())
            doc_hash = inv_data.get("data", {}).get("file_hash", "")

        # Extract run_id from workspace path
        run_id = input.workspace.name

        # Build report
        report = _build_report(doc_name, ledger, doc_hash, run_id)

        # Save
        review_dir = input.workspace / "review"
        review_dir.mkdir(parents=True, exist_ok=True)
        report_name = f"REVIEW_{Path(doc_name).stem}.md"
        report_path = review_dir / report_name
        report_path.write_text(report, encoding="utf-8")

        # Also save to stage3
        stage3_path = input.workspace / "stage3" / report_name
        stage3_path.parent.mkdir(parents=True, exist_ok=True)
        stage3_path.write_text(report, encoding="utf-8")

        counts = ledger.summary_counts()

        logger.info(
            f"[md_review_report_assemble] Report generated: {report_name} "
            f"({counts['total_changes']} changes)"
        )

        return {
            "report_path": str(report_path),
            "report_name": report_name,
            "counts": counts,
        }

    def summarize(self, data: Dict[str, Any]) -> str:
        counts = data.get("counts", {})
        return (
            f"Review report: {data['report_name']}. "
            f"{counts.get('total_changes', 0)} changes, "
            f"{counts.get('attention_changes', 0)} attention, "
            f"{counts.get('silent_minor', 0)} silent."
        )
